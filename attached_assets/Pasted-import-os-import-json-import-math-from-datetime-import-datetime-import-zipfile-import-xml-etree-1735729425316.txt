import os
import json
import math
from datetime import datetime
import zipfile
import xml.etree.ElementTree as ET
from openpyxl import load_workbook
import openpyxl.cell.cell
from openpyxl.utils import get_column_letter
from typing import Dict, Any, List, Optional, Tuple
from openai_helper import OpenAIHelper
import traceback
from pathlib import Path
import tempfile

class ExcelMetadataExtractor:

    def __init__(self, file_obj):
        self.file_obj = file_obj
        self.workbook = load_workbook(file_obj, data_only=True)
        self.openai_helper = OpenAIHelper()
        self.MAX_CELLS_PER_ANALYSIS = 100
        self.ns = {
            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
            'xdr':
            'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
            'r':
            'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
            'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
            'sp': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'pr':
            'http://schemas.openxmlformats.org/package/2006/relationships'
        }

    # ... (get_sheet_drawing_relations, extract_drawing_info, _extract_shape_info, ...)

    def detect_regions(self, sheet) -> List[Dict[str, Any]]:
        """Enhanced region detection including drawings and surrounding text"""
        regions: List[Dict[str, Any]] = []
        drawing_regions: List[Dict[str, Any]] = []
        table_regions: List[Dict[str, Any]] = []
        text_regions: List[Dict[str, Any]] = []
        processed_cells = set()

        try:
            # 1. 描画オブジェクト領域の検出 (既存の処理)
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_zip = os.path.join(temp_dir, 'temp.xlsx')
                with open(temp_zip, 'wb') as f:
                    self.file_obj.seek(0)
                    f.write(self.file_obj.read())

                with zipfile.ZipFile(temp_zip, 'r') as excel_zip:
                    sheet_drawing_map = self.get_sheet_drawing_relations(
                        excel_zip)
                    sheet_name = sheet.title
                    if sheet_name in sheet_drawing_map:
                        drawing_path = sheet_drawing_map[sheet_name]
                        drawings = self.extract_drawing_info(
                            sheet, excel_zip, drawing_path)
                        for drawing in drawings:
                            # ... (既存の描画オブジェクト領域処理)
                            drawing_regions.append(region_info)
                            from_col = drawing["coordinates"]["from"]["col"]
                            from_row = drawing["coordinates"]["from"]["row"]
                            to_col = drawing["coordinates"]["to"]["col"]
                            to_row = drawing["coordinates"]["to"]["row"]
                            for r in range(from_row, to_row + 1):
                                for c in range(from_col, to_col + 1):
                                    processed_cells.add(
                                        f"{get_column_letter(c)}{r}")

            # 2. テーブル領域の検出
            print("\nProcessing table regions")
            for row in range(1, min(sheet.max_row + 1, 200)):  # 探索範囲を調整
                for col in range(1, min(sheet.max_column + 1, 50)):  # 探索範囲を調整
                    cell_coord = f"{get_column_letter(col)}{row}"
                    if cell_coord in processed_cells or sheet.cell(
                            row=row, column=col).value is None:
                        continue

                    # テーブル候補の評価 (データ密度、罫線、ヘッダーらしさ)
                    if self._is_potential_table_start(sheet, row, col):
                        max_row, max_col = self.find_region_boundaries(
                            sheet, row, col)
                        cells_data = self.extract_region_cells(
                            sheet, row, col, max_row, max_col)
                        merged_cells = self.get_merged_cells_info(
                            sheet, row, col, max_row, max_col)

                        # ヘッダー構造の分析 (修正)
                        header_structure = self.detect_header_structure(
                            cells_data, merged_cells)
                        if isinstance(header_structure, str):
                            header_structure = json.loads(header_structure)

                        region_type = "table" # 仮にテーブルとする

                        region_metadata = {
                            "regionType": region_type,
                            "range":
                            f"{get_column_letter(col)}{row}:{get_column_letter(max_col)}{max_row}",
                            "sampleCells": cells_data[:3],
                            "mergedCells": merged_cells,
                            "headerStructure": header_structure
                        }
                        table_regions.append(region_metadata)
                        print(f"Added table region: {region_metadata['range']}")

                        # 処理済みセルに追加
                        for r in range(row, max_row + 1):
                            for c in range(col, max_col + 1):
                                processed_cells.add(
                                    f"{get_column_letter(c)}{r}")

            # 3. 周辺テキスト領域の検出 (簡略化)
            print("\nProcessing potential text regions")
            for row in range(1, sheet.max_row + 1):
                for col in range(1, sheet.max_column + 1):
                    cell_coord = f"{get_column_letter(col)}{row}"
                    if cell_coord not in processed_cells and sheet.cell(
                            row=row, column=col).value is not None:
                        # 簡単なテキスト領域として検出
                        max_row_text, max_col_text = self.find_region_boundaries(
                            sheet, row, col) # 既存の境界検出を利用
                        text_content = self.extract_region_text(sheet, row, col, max_row_text, max_col_text)
                        text_regions.append({
                            "regionType": "text",
                            "range": f"{get_column_letter(col)}{row}:{get_column_letter(max_col_text)}{max_row_text}",
                            "text": text_content
                        })
                        for r in range(row, max_row_text + 1):
                            for c in range(col, max_col_text + 1):
                                processed_cells.add(f"{get_column_letter(c)}{r}")

            regions.extend(drawing_regions)
            regions.extend(table_regions)
            regions.extend(text_regions)

            print(
                f"\nTotal regions detected: {len(regions)} (Drawings: {len(drawing_regions)}, Tables: {len(table_regions)}, Texts: {len(text_regions)})"
            )
            return regions
        except Exception as e:
            print(
                f"Error in detect_regions: {str(e)}\n{traceback.format_exc()}")
            raise

    def _is_potential_table_start(self, sheet, row, col) -> bool:
        """簡易的なテーブル開始位置の判定"""
        # データが存在するか
        if sheet.cell(row=row, column=col).value is None:
            return False

        # 簡単なヘッダーらしさのチェック (上の行に文字列が存在するか)
        if row > 1 and isinstance(sheet.cell(row=row - 1, column=col).value, str):
            return True

        # 左や上のセルにデータが存在するか (ある程度連続したデータ領域であるか)
        if col > 1 and sheet.cell(row=row, column=col - 1).value is not None:
            return True
        if row > 1 and sheet.cell(row=row - 1, column=col).value is not None:
            return True

        return False

    def extract_region_text(self, sheet, start_row, start_col, max_row, max_col) -> str:
        """領域からテキストを抽出"""
        text_parts = []
        for row in range(start_row, max_row + 1):
            row_texts = []
            for col in range(start_col, max_col + 1):
                cell_value = sheet.cell(row=row, column=col).value
                if cell_value is not None:
                    row_texts.append(str(cell_value))
            text_parts.append(" ".join(row_texts))
        return "\n".join(text_parts)

    def detect_header_structure(
            self, cells_data: List[List[Dict[str, Any]]],
            merged_cells: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze the header structure with rule-based and LLM assistance"""
        try:
            if not cells_data:
                return {"headerType": "none", "headerRowsCount": 0, "headerRows": [], "headerRange": "N/A"}

            # 1. ルールベースでのヘッダー候補の特定
            potential_header_rows = []
            for i, row_data in enumerate(cells_data[:2]):  # 最初の2行を候補とする
                is_header_row = True
                for cell_info in row_data:
                    cell_value = cell_info.get("value", "")
                    # キーワードチェック
                    if any(keyword in cell_value for keyword in ["コード", "名", "単位", "金額"]):
                        is_header_row = True
                        break
                    # 下の行とのデータ型比較 (簡易版)
                    if i + 1 < len(cells_data):
                        next_row_data = cells_data[i + 1]
                        if next_row_data and cell_info["col"] <= len(next_row_data):
                            current_type = cell_info.get("type")
                            next_cell_info = next_row_data[cell_info["col"] - 1]
                            next_type = next_cell_info.get("type")
                            if current_type != "text" and next_type == "text":
                                is_header_row = False
                                break
                if is_header_row:
                    potential_header_rows.append(i + 1)

            # 2. LLMによる分析 (ヘッダー候補を考慮)
            sample_data = cells_data[:4]
            analysis_input = {
                "sampleData": sample_data,
                "potentialHeaderRows": potential_header_rows
            }
            analysis = self.openai_helper.analyze_table_structure_with_hints(
                json.dumps(analysis_input)) # プロンプトを調整した新しいメソッドを想定
            if isinstance(analysis, str):
                analysis = json.loads(analysis)

            header_rows = analysis.get("headerRows", [])

            # 3. 結合セル情報を利用してヘッダー行を補完 (既存の処理)
            merged_header_rows = set()
            for merged_cell in merged_cells:
                merged_range = merged_cell.get("range", "")
                if ":" in merged_range:
                    start_cell, end_cell = merged_range.split(":")
                    start_row = int("".join(filter(str.isdigit, start_cell)))
                    end_row = int("".join(filter(str.isdigit, end_cell)))
                    for row in range(start_row, end_row + 1):
                        merged_header_rows.add(row)

            all_header_rows = sorted(
                set(header_rows).union(merged_header_rows))

            if all_header_rows:
                min_row = min(all_header_rows)
                max_row = max(all_header_rows)
                header_range = f"{min_row}-{max_row}" if min_row != max_row else f"{min_row}"
            else:
                header_range = "N/A"

            return {
                "headerType": analysis.get("headerType", "none"),
                "headerRowsCount": len(all_header_rows),
                "headerRows": all_header_rows,
                "headerRange": header_range
            }

        except Exception as e:
            print(f"Error in detect_header_structure: {str(e)}")
            return {
                "headerType": "none",
                "headerRowsCount": 0,
                "headerRows": [],
                "headerRange": "N/A"
            }

    # ... (get_file_metadata, analyze_cell_type, find_region_boundaries, get_merged_cells_info, extract_region_cells, get_sheet_metadata, extract_all_metadata)