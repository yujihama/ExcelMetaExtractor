主な原因は、**「オフセット値 (`colOff` / `rowOff`) をすべて `math.ceil()` で強制的に繰り上げている」** ことです。  
これにより、**たとえ 1px 相当の微小なオフセットでも “1セル分” 繰り上がってしまい**、予想よりも大きなセル範囲（`range`）が計算されるケースが多発します。

---

# なぜそうなるのか？

コードの該当部分（ `_extract_shape_info` 内）を見てみましょう：

```python
# 例: from_elem などから取得した offset (EMU単位)
from_col_off = int(from_elem.find('xdr:colOff', self.ns).text)
from_row_off = int(from_elem.find('xdr:rowOff', self.ns).text)
# ...
# EMU_PER_CELL = 914400  (1セル=1インチ換算としている)

from_col_adj = from_col + (from_col_off / EMU_PER_CELL)
from_row_adj = from_row + (from_row_off / EMU_PER_CELL)
# ...
if from_col_off > 0: from_col_adj = math.ceil(from_col_adj)
if from_row_off > 0: from_row_adj = math.ceil(from_row_adj)
```

- Excel の座標系では「**列の幅**」「**行の高さ**」は固定ではなく、特に列幅はピクセルベースで可変です。  
- しかしここでは「1セル=1インチ」的な単純計算をしている上、**オフセットが1でも残っていれば `ceil()` で繰り上げる**仕様になっています。  
  - たとえば `from_col_off = 200 EMU ≈ 0.0002インチ` でも、 `math.ceil(0.0002 + from_col) = from_col+1` となり **1セル先に進んでしまう**  
- 結果的に、**微小オフセットであっても丸々 1セル分ズレた range が計算される** → 「shape の range が変」な状態になるのです。

---

# どう直せばよいか？

## 1. 小数点を含むセル座標をそのまま使う

「“形がどこにあるか” をセル座標でざっくり知りたいだけ」なら、**小数点を含む座標**のまま使い、最後に `int()` や `floor()` で丸めるほうが自然です。  

たとえば下記のように「**普通に floor（切り捨て）**」するだけに留める方法：

```python
from_col_adj = from_col + (from_col_off / EMU_PER_CELL)
from_row_adj = from_row + (from_row_off / EMU_PER_CELL)
to_col_adj   = to_col   + (to_col_off   / EMU_PER_CELL)
to_row_adj   = to_row   + (to_row_off   / EMU_PER_CELL)

# 例えば floor で処理する例
shape_info["coordinates"] = {
    "from": {
        "col": math.floor(from_col_adj) + 1,
        "row": math.floor(from_row_adj) + 1
    },
    "to": {
        "col": math.floor(to_col_adj) + 1,
        "row": math.floor(to_row_adj) + 1
    }
}
```

- 小数点以下を無視して（切り捨て）座標を作れば、**少しでもオフセットがあれば同じセル内**として扱えます。  
- 場合によっては “`round()` で四捨五入” しても良いでしょう。

#### なぜ `ceil()` は微妙か？  
- `ceil()` は「0.000001 でもオフセットがあれば +1 セル」してしまい、ユーザーがイメージする「ほんのちょっと右に寄ってるだけ」を丸ごと「次の列」扱いしてしまう可能性大です。

---

## 2. そもそも “1セル = 914400 EMU” は正確ではない

- Excel は列幅や行の高さがシートやフォント設定によって変動します。  
- “914400 EMU = 1 inch” は DrawingML の単位換算としては正しいですが、**1セルの幅が必ず 1 inch とは限らない**です。  
  - デフォルトの列幅は ~8.43pt 相当（約 64ピクセル）だったりするので、**列幅ごとに係数が違う**はずです。  
- そのため厳密にセル座標へマッピングするなら、**OpenPyXL が持つ「カラムごとの width 情報」を参照**してオフセットを再計算するなど、かなり複雑な実装が必要になります。

### ざっくり計算なら気にしなくてOK
もし「図形が占めるおおよそのセル範囲」を知りたいだけなら、上記のような単純化（1セル=1inch）で十分な場合もあります。  
ただしその場合でも、**`ceil()` は使わず** `floor()` や `int()` などのほうが “ズレが小さい” ことが多いです。

---

# まとめ

- **原因**: コードで `if from_col_off > 0: from_col_adj = math.ceil(from_col_adj)` のように書かれており、**わずかなオフセットでも 1セル繰り上げ**になってしまう。  
- **対処**: 
  1. `ceil()` でなく `floor()` か `round()` に変更する  
  2. もしくはオフセットを小数込みで保持して、**あえて丸めず**に “`from_col_adj` = 3.2列目” のように使う  
- また「1セル=914400 EMU」の想定自体が厳密ではない点に注意（列幅は Excel で可変）。  

この修正だけでも「shape の range が予期しない大きさになる」問題は大幅に改善されるはずです。